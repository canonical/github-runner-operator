#!/usr/bin/env bash

timestamp=$(date +%s)

# Disable exit-on-error, due the need for error handling.
set +e

{% if issue_metrics %}
jq -n \
  --arg workflow "$GITHUB_WORKFLOW" \
  --arg repository "$GITHUB_REPOSITORY" \
  --arg event "$GITHUB_EVENT_NAME" \
  --argjson timestamp "$timestamp" \
  --arg workflow_run_id "$GITHUB_RUN_ID" \
  '{
    "workflow": $workflow,
    "repository": $repository,
    "event": $event,
    "timestamp": $timestamp,
    "workflow_run_id": $workflow_run_id
  }' > "{{ metrics_exchange_path }}/pre-job-metrics.json" || true
{% endif %}

{% if do_repo_policy_check %}
  logger -s "Repo policy check is marked for deprecation. Consider using `allow_external_contributor` instead"

    # Log common env variables.
    logger -s "GITHUB_EVENT_NAME: ${GITHUB_EVENT_NAME}, \
      GITHUB_REPOSITORY: ${GITHUB_REPOSITORY}, \
      GITHUB_SHA: ${GITHUB_SHA}"

    # Prepare curl arguments
    CURL_ARGS=(
      --silent
      --show-error
      --max-time 60
      --noproxy '*'
      --fail-with-body
      -o repo_check_output.txt
      --stderr repo_check_error.txt
      --write-out "%{http_code}"
      -H 'Authorization: Bearer {{repo_policy_one_time_token}}'
      -H 'Content-Type: application/json'
    )

    # Set REPO_CHECK to a failure code as a safe guard.
    REPO_CHECK=1

    # Special Workflow dispatch repo-policy-compliance service check designed to fail:
    if [[ "${GITHUB_WORKFLOW}" == "Workflow Dispatch Failure Tests 2a34f8b1-41e4-4bcb-9bbf-7a74e6c482f7" ]]; then
      logger -s "Running the test workflow for integration tests, this test is configured to fail"

      REPO_CHECK_HTTP_CODE=$(curl "${CURL_ARGS[@]}" \
          -X POST \
          {{repo_policy_base_url}}/always-fail/check-run)
      REPO_CHECK=$?

    # Pull request - Request repo-policy-compliance service check:
    elif [[ "${GITHUB_EVENT_NAME}" ==  "pull_request" ]]; then

      GITHUB_SOURCE_REPOSITORY=$(cat "${GITHUB_EVENT_PATH}" | jq -r '.pull_request.head.repo.full_name')
      COMMIT_SHA=$(cat "${GITHUB_EVENT_PATH}" | jq -r '.pull_request.head.sha')

      logger -s " \
      GITHUB_SOURCE_REPOSITORY: ${GITHUB_SOURCE_REPOSITORY} \
      GITHUB_BASE_REF: ${GITHUB_BASE_REF}, \
      GITHUB_HEAD_REF: ${GITHUB_HEAD_REF}, \
      COMMIT_SHA: ${COMMIT_SHA}"

      REPO_CHECK_HTTP_CODE=$(curl "${CURL_ARGS[@]}" \
          -d "{\"repository_name\": \"${GITHUB_REPOSITORY}\", \"source_repository_name\": \"${GITHUB_SOURCE_REPOSITORY}\", \"target_branch_name\": \"${GITHUB_BASE_REF}\", \"source_branch_name\": \"${GITHUB_HEAD_REF}\", \"commit_sha\": \"${COMMIT_SHA}\"}" \
          {{repo_policy_base_url}}/pull_request/check-run)
      REPO_CHECK=$?

    else
      # Workflow dispatch, Push and Schedule use their respective endpoints, all other events use default by default.
      CHECK_NAME="default"
      if [[ "${GITHUB_EVENT_NAME}" == "workflow_dispatch" ]] || [[ "${GITHUB_EVENT_NAME}" == "push" ]] || [[ "${GITHUB_EVENT_NAME}" == "schedule" ]]; then
        CHECK_NAME="${GITHUB_EVENT_NAME}"
      fi

      logger -s "GITHUB_REF_NAME: ${GITHUB_REF_NAME}"

      REPO_CHECK_HTTP_CODE=$(curl "${CURL_ARGS[@]}" \
          -d "{\"repository_name\": \"${GITHUB_REPOSITORY}\"}" \
          {{repo_policy_base_url}}/${CHECK_NAME}/check-run)
      REPO_CHECK=$?

    fi

    if [[ $REPO_CHECK -ne 0 ]]; then
        if [[ -s repo_check_output.txt ]]; then
            logger -p user.error -s -f repo_check_output.txt
        fi
        if [[ -s repo_check_error.txt ]]; then
            logger -p user.error -s -f repo_check_error.txt
        fi
        if [[ $REPO_CHECK_HTTP_CODE -ge 500 ]] && [[ $REPO_CHECK_HTTP_CODE -lt 600 ]]; then
            logger -p user.error -s "The repository setup check failed with HTTP code ${REPO_CHECK_HTTP_CODE}."
            logger -p user.error -s "This runner will be stopped or lost, please contact the repo-policy-compliance server operators or try again later."
        else
            logger -p user.error -s "Stopping execution of jobs due to repository setup is not compliant with policies."
            logger -p user.error -s "This runner will be stopped or lost, please fix the setup of the repository, then rerun this job."
        fi

        # Killing the runner.Listener process to stop the runner application. This will prevent jobs from being executed.
        pkill -2 Runner.Listener


        {% if issue_metrics %}
            # Write Post Job metrics with status "repo-policy-check-failure" .
            # We write it here, rather than relying on the post-job script,
            # as it may not run due to the poweroff command below.
            post_job_timestamp=$(date +%s)

            jq -n \
              --argjson timestamp "$post_job_timestamp" \
              --argjson http_code "$REPO_CHECK_HTTP_CODE" \
              '{
                "timestamp": $timestamp,
                "status": "repo-policy-check-failure",
                "status_info": {code: $http_code}
              }' > "{{ metrics_exchange_path }}/post-job-metrics.json" || true
        {% endif %}

      # Shutdown the instance as a safe guard. The time delay is needed for the runner application to upload the logs.
      bash -c "sleep 10; sudo systemctl poweroff -i" &

      exit 1

    fi

    logger -s "The repository setup check has passed, proceeding to execute jobs"
{% endif %}

{% if not allow_external_contributor %}
  # Check author association for events that can be triggered by external contributors
  # https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows
  # This does not cover all possible events, only the most common ones that can be triggered by external contributors.
  
  # Determine event type using regex
  IS_PR_EVENT=$([[ "$GITHUB_EVENT_NAME" =~ ^(pull_request|pull_request_target|pull_request_review|pull_request_review_comment)$ ]] && echo true || echo false)
  logger -s "IS_PR_EVENT: $IS_PR_EVENT, GITHUB_EVENT_NAME: $GITHUB_EVENT_NAME"
  
  # For PR events, check if internal or fork PR
  if [[ "$IS_PR_EVENT" == "true" ]]; then
    PR_HEAD_REPO=$(jq -r '.pull_request.head.repo.full_name // empty' "$GITHUB_EVENT_PATH")
    PR_BASE_REPO=$(jq -r '.pull_request.base.repo.full_name // empty' "$GITHUB_EVENT_PATH")
    
    # Check if this is an internal PR (same repository)
    IS_INTERNAL_PR=$([[ -n "$PR_HEAD_REPO" && -n "$PR_BASE_REPO" && "$PR_HEAD_REPO" == "$PR_BASE_REPO" ]] && echo true || echo false)
    logger -s "IS_INTERNAL_PR: $IS_INTERNAL_PR (head: $PR_HEAD_REPO, base: $PR_BASE_REPO)"
  fi
  
  # Skip check for internal PRs, perform check for external PRs and issue comments
  if [[ "$IS_PR_EVENT" == "true" && "$IS_INTERNAL_PR" == "true" ]]; then
    logger -s "Internal PR detected, skipping author association check"
    logger -s "The contributor check has passed, proceeding to execute jobs"
  
  # Perform author association check for fork PRs
  elif [[ "$IS_PR_EVENT" == "true" && "$IS_INTERNAL_PR" == "false" ]]; then
    # Fork PR or repo info unavailable - perform author association check
    if [[ -n "$PR_HEAD_REPO" && -n "$PR_BASE_REPO" ]]; then
      logger -s "Fork PR detected, performing author association check"
    else
      logger -s "Repository information unavailable, performing author association check"
    fi
    
    # Get author association from appropriate field based on event type
    if [[ "${GITHUB_EVENT_NAME}" == "pull_request" || "${GITHUB_EVENT_NAME}" == "pull_request_target" ]]; then
      AUTHOR_ASSOCIATION=$(jq -r '.pull_request.author_association // empty' "$GITHUB_EVENT_PATH")
    elif [[ "${GITHUB_EVENT_NAME}" == "pull_request_review" ]]; then
      AUTHOR_ASSOCIATION=$(jq -r '.review.author_association // empty' "$GITHUB_EVENT_PATH")
    elif [[ "${GITHUB_EVENT_NAME}" == "pull_request_review_comment" ]]; then
      AUTHOR_ASSOCIATION=$(jq -r '.comment.author_association // empty' "$GITHUB_EVENT_PATH")
    fi
    logger -s "Author association: $AUTHOR_ASSOCIATION"

    IS_ALLOWED_AUTHOR=$([[ "$AUTHOR_ASSOCIATION" == "OWNER" || "$AUTHOR_ASSOCIATION" == "MEMBER" || "$AUTHOR_ASSOCIATION" == "COLLABORATOR" ]] && echo true || echo false)
    if [[ "$IS_ALLOWED_AUTHOR" == "false" ]]; then
      logger -p user.error -s "Insufficient user authorization (author_association). Only OWNER, MEMBER, or COLLABORATOR may run workflows."
      exit 1
    fi

    logger -s "The contributor check has passed, proceeding to execute jobs"
  
  # Handle issue context events - always perform author association check
  elif [[ "${GITHUB_EVENT_NAME}" == "issue_comment" ]]; then
    AUTHOR_ASSOCIATION=$(jq -r '.issue.author_association // .comment.author_association // empty' "$GITHUB_EVENT_PATH")
    logger -s "Author association: $AUTHOR_ASSOCIATION"

    IS_ALLOWED_AUTHOR=$([[ "$AUTHOR_ASSOCIATION" == "OWNER" || "$AUTHOR_ASSOCIATION" == "MEMBER" || "$AUTHOR_ASSOCIATION" == "COLLABORATOR" ]] && echo true || echo false)
    if [[ "$IS_ALLOWED_AUTHOR" == "false" ]]; then
      logger -p user.error -s "Insufficient user authorization (author_association). Only OWNER, MEMBER, or COLLABORATOR may run workflows."
      exit 1
    fi

    logger -s "The contributor check has passed, proceeding to execute jobs"
  
  # Skip check for other events
  else
    logger -s "Skipping contributor check for event: ${GITHUB_EVENT_NAME}"
  fi
{% endif %}

if [[ -n "$DOCKERHUB_MIRROR" ]]; then
  logger -s "A private docker registry is setup as a dockerhub mirror for this self-hosted runner."
  logger -s "The docker daemon on this self-hosted runner is configured to use the dockerhub mirror."
  logger -s "The URL to the private docker registry is in the DOCKERHUB_MIRROR environment variable."
  logger -s "For microk8s, see instructions here: https://microk8s.io/docs/dockerhub-limits"
fi

{% if custom_pre_job_script %}
# write the custom pre-job script to a temporary file, use special delimiter (and not EOF) to avoid same is reused in the script
cat > /tmp/custom_pre_job_script <<'cc8eaf15-148a-4f10-8553-1b23fd5729d9'
{{ custom_pre_job_script | safe }}
cc8eaf15-148a-4f10-8553-1b23fd5729d9
chmod +x /tmp/custom_pre_job_script
logger -s "Running custom pre-job script"
/tmp/custom_pre_job_script || logger -s "Custom pre-job script failed, continuing with the job"
rm /tmp/custom_pre_job_script || logger -s "Failed to remove custom pre-job script"
{% endif %}