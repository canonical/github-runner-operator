#!/usr/bin/env bash

timestamp=$(date +%s)

# Disable exit-on-error, due the need for error handling.
set +e

{% if issue_metrics %}
jq -n \
  --arg workflow "$GITHUB_WORKFLOW" \
  --arg repository "$GITHUB_REPOSITORY" \
  --arg event "$GITHUB_EVENT_NAME" \
  --argjson timestamp "$timestamp" \
  --arg workflow_run_id "$GITHUB_RUN_ID" \
  '{
    "workflow": $workflow,
    "repository": $repository,
    "event": $event,
    "timestamp": $timestamp,
    "workflow_run_id": $workflow_run_id
  }' > "{{ metrics_exchange_path }}/pre-job-metrics.json" || true
{% endif %}

{% if not allow_external_contributor %}
  # Check author association for events that can be triggered by external contributors
  # https://docs.github.com/en/actions/reference/workflows-and-actions/events-that-trigger-workflows
  # This does not cover all possible events, only the most common ones that can be triggered by external contributors.
  
  check_author_association() {
    local event_name="$1"
    local event_path="$2"
    

    # Skip check for non-contributor events
    if [[ "$event_name" != "pull_request" && "$event_name" != "pull_request_target" && 
          "$event_name" != "pull_request_review" && "$event_name" != "pull_request_review_comment" && 
          "$event_name" != "issue_comment" ]]; then
      logger -s "Contributor check skipped for event: $event_name"
      return 0
    fi
    
    # Helper function to check if author association is allowed
    is_author_allowed() {
      local ALLOWED_AUTHORIZATIONS=("OWNER" "MEMBER" "COLLABORATOR")
      local author="$1"
      local auth
      for auth in "${ALLOWED_AUTHORIZATIONS[@]}"; do
        if [[ "$author" == "$auth" ]]; then
          return 0
        fi
      done
      return 1
    }
    
    # Handle issue comment events - always check author association
    if [[ "$event_name" == "issue_comment" ]]; then
      local author_association=$(jq -r '.comment.author_association // empty' "$event_path")
      local is_allowed=$(is_author_allowed "$author_association" && echo "true" || echo "false")
      
      logger -s "Author association: $author_association, is allowed: $is_allowed"
      
      if [[ "$is_allowed" == "false" ]]; then
        logger -p user.error -s "Insufficient user authorization - only OWNER, MEMBER, or COLLABORATOR may run workflows"
        return 1
      fi
      return 0
    fi
    
    # Extract PR repository information for PR events
    local pr_head_repo=$(jq -r '.pull_request.head.repo.full_name // empty' "$event_path")
    local pr_base_repo=$(jq -r '.pull_request.base.repo.full_name // empty' "$event_path")
    
    # Check if this is an internal PR (same repository)
    local is_internal_pr=$([[ -n "$pr_head_repo" && -n "$pr_base_repo" && "$pr_head_repo" == "$pr_base_repo" ]] && echo true || echo false)
    logger -s "IS_INTERNAL_PR: $is_internal_pr (head: $pr_head_repo, base: $pr_base_repo)"
    
    # Skip check for internal PRs
    if [[ "$is_internal_pr" == "true" ]]; then
      logger -s "Internal PR detected - contributor check skipped"
      return 0
    fi
    
    # Fork PR or missing repository info - perform author association check
    logger -s "PR HEAD repo: $pr_head_repo, PR BASE repo: $pr_base_repo"
    logger -s "Fork PR or missing repository detected - performing contributor check"
    
    # Get author association from appropriate field based on event type
    local author_association=""
    if [[ "$event_name" == "pull_request" || "$event_name" == "pull_request_target" ]]; then
      author_association=$(jq -r '.pull_request.author_association // empty' "$event_path")
    elif [[ "$event_name" == "pull_request_review" ]]; then
      author_association=$(jq -r '.review.author_association // empty' "$event_path")
    elif [[ "$event_name" == "pull_request_review_comment" ]]; then
      author_association=$(jq -r '.comment.author_association // empty' "$event_path")
    fi
    
    local is_allowed=$(is_author_allowed "$author_association" && echo "true" || echo "false")
    logger -s "Author association: $author_association, is allowed: $is_allowed"
    
    if [[ "$is_allowed" == "false" ]]; then
      logger -p user.error -s "Insufficient user authorization - only OWNER, MEMBER, or COLLABORATOR may run workflows"
      return 1
    fi
    
    return 0
  }
  
  # Perform the author association check
  check_author_association "$GITHUB_EVENT_NAME" "$GITHUB_EVENT_PATH"
  if [[ $? -ne 0 ]]; then
    logger -s "Contributor check failed - aborting job execution"
    jq -n \
        --argjson timestamp "$timestamp" \
        '{
          "timestamp": $timestamp,
          "status": "external-contributor-check-failure"
        }' > "{{ metrics_exchange_path }}/post-job-metrics.json" || true
    exit 1
  fi
  logger -s "Contributor check passed - proceeding to execute jobs"
{% endif %}

if [[ -n "$DOCKERHUB_MIRROR" ]]; then
  logger -s "A private docker registry is setup as a dockerhub mirror for this self-hosted runner."
  logger -s "The docker daemon on this self-hosted runner is configured to use the dockerhub mirror."
  logger -s "The URL to the private docker registry is in the DOCKERHUB_MIRROR environment variable."
  logger -s "For microk8s, see instructions here: https://microk8s.io/docs/dockerhub-limits"
fi

{% if custom_pre_job_script %}
# write the custom pre-job script to a temporary file, use special delimiter (and not EOF) to avoid same is reused in the script
cat > /tmp/custom_pre_job_script <<'cc8eaf15-148a-4f10-8553-1b23fd5729d9'
{{ custom_pre_job_script | safe }}
cc8eaf15-148a-4f10-8553-1b23fd5729d9
chmod +x /tmp/custom_pre_job_script
logger -s "Running custom pre-job script"
/tmp/custom_pre_job_script || logger -s "Custom pre-job script failed, continuing with the job"
rm /tmp/custom_pre_job_script || logger -s "Failed to remove custom pre-job script"
{% endif %}